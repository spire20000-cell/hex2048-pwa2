<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hex 2048 (PWA)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.webmanifest">
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("service-worker.js");
    }
  </script>
  <style>
    body {
      background: #f5efe4;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      margin-top: 10px;
      font-size: 20px;
      color: #6d5b4a;
    }
    #game {
      position: relative;
      margin: 10px auto 10px;
      width: 420px;
      height: 420px;
      background: #f5efe4;
      overflow: hidden;
      touch-action: manipulation;
    }
    .tile {
      position: absolute;
      width: 70px;
      height: 70px;
      background: #eee0cf;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #fff;
      font-size: 16px;
      transition: 0.12s;
    }
    .scorebar {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-bottom: 6px;
    }
    .board-stat {
      background: #ddcec0;
      border-radius: 10px;
      padding: 6px 14px;
      color: #fff;
      font-weight: 600;
      min-width: 90px;
    }
    .v2 { background: #ede3d5; color: #6d5b4a; }
    .v4 { background: #d7c3af; }
    .v8 { background: #f3a66a; }
    .v16 { background: #f17b5a; }
    .v32 { background: #f15b4f; }
    .v64 { background: #e65163; }
    .v128 { background: #d1c742; }
    .v256 { background: #c1b631; }
    .v512 { background: #b0a510; }
    .v1024 { background: #9c7fe0; }
    .v2048 { background: #7f55d0; }
    .v4096 { background: #5a3f88; }
    .v8192 { background: #442a70; }
    .controls {
      font-size: 13px;
      color: #7a6a5b;
      margin-bottom: 4px;
    }
    .buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 6px;
      max-width: 420px;
      margin: 0 auto 20px;
    }
    .buttons button {
      flex: 0 0 30%;
      padding: 10px 0;
      font-size: 15px;
      background: #c9b29e;
      color: #fff;
      border: none;
      border-radius: 10px;
    }
    @media (max-width: 460px) {
      #game { transform: scale(0.85); }
      .buttons { max-width: 360px; }
    }
  </style>
</head>
<body>
  <h1>Hex 2048</h1>
  <div class="scorebar">
    <div class="board-stat">Score: <span id="score">0</span></div>
    <div class="board-stat">Best: <span id="best">0</span></div>
  </div>
  <div class="controls">
    Tap the buttons to slide the hex board.
  </div>
  <div id="game"></div>
  <div class="buttons">
    <button data-dir="q">Q ↑</button>
    <button data-dir="w">W ↗</button>
    <button data-dir="e">E →</button>
    <button data-dir="a">A ←</button>
    <button data-dir="s">S ↙</button>
    <button data-dir="d">D ↓</button>
  </div>

  <script>
    const RADIUS = 3;
    const CELL_SIZE = 70;
    const HEX_W = CELL_SIZE;
    const HEX_H = CELL_SIZE * 0.9;
    const CENTER_X = 210;
    const CENTER_Y = 210;

    const DIRECTIONS = {
      "q": {q: 0,  r: -1},
      "w": {q: 1,  r: -1},
      "e": {q: 1,  r: 0},
      "a": {q: -1, r: 0},
      "s": {q: -1, r: 1},
      "d": {q: 0,  r: 1},
    };

    const gameEl = document.getElementById("game");
    const scoreEl = document.getElementById("score");
    const bestEl = document.getElementById("best");

    let board = {};
    let tilesEls = {};
    let score = 0;
    let best = Number(localStorage.getItem("hex2048-best") || "0");
    bestEl.textContent = best;

    const cells = [];
    for (let q = -RADIUS; q <= RADIUS; q++) {
      for (let r = -RADIUS; r <= RADIUS; r++) {
        const s = -q - r;
        if (Math.abs(s) <= RADIUS) {
          cells.push({q, r});
        }
      }
    }

    function axialToPixel(q, r) {
      const x = (Math.sqrt(3) * q + Math.sqrt(3)/2 * r) * (HEX_H/1.2);
      const y = (3/2 * r) * (HEX_H/1.2);
      return {
        x: CENTER_X + x - HEX_W/2,
        y: CENTER_Y + y - HEX_H/2
      };
    }

    function renderBoard() {
      for (const key in tilesEls) {
        tilesEls[key].remove();
      }
      tilesEls = {};
      for (const cell of cells) {
        const key = keyOf(cell.q, cell.r);
        const val = board[key];
        if (!val) continue;
        const pos = axialToPixel(cell.q, cell.r);
        const div = document.createElement("div");
        div.className = "tile v" + val;
        div.style.left = pos.x + "px";
        div.style.top = pos.y + "px";
        div.textContent = val;
        gameEl.appendChild(div);
        tilesEls[key] = div;
      }
    }

    function keyOf(q, r) {
      return q + "," + r;
    }

    function randomEmptyCell() {
      const empties = cells.filter(c => !board[keyOf(c.q, c.r)]);
      if (empties.length === 0) return null;
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function addRandomTile() {
      const cell = randomEmptyCell();
      if (!cell) return;
      const key = keyOf(cell.q, cell.r);
      board[key] = Math.random() < 0.9 ? 2 : 4;
    }

    function startGame() {
      board = {};
      score = 0;
      addRandomTile();
      addRandomTile();
      updateScore();
      drawBackgroundHexes();
      renderBoard();
    }

    function updateScore() {
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
        localStorage.setItem("hex2048-best", String(best));
      }
    }

    function getLinesForDirection(dir) {
      const {q: dq, r: dr} = dir;
      const lines = {};
      for (const c of cells) {
        const k = c.q * dr - c.r * dq;
        if (!lines[k]) lines[k] = [];
        lines[k].push(c);
      }
      for (const k in lines) {
        lines[k].sort((a, b) => {
          const da = a.q * dq + a.r * dr;
          const db = b.q * dq + b.r * dr;
          return db - da;
        });
      }
      return Object.values(lines);
    }

    function move(dirKey) {
      const dir = DIRECTIONS[dirKey];
      if (!dir) return;
      const lines = getLinesForDirection(dir);
      let moved = false;
      for (const line of lines) {
        const values = line.map(c => board[keyOf(c.q, c.r)] || 0);
        const newVals = [];
        for (let i = 0; i < values.length; i++) {
          let v = values[i];
          if (v === 0) continue;
          let next = i + 1;
          while (next < values.length && values[next] === 0) next++;
          if (next < values.length && values[next] === v) {
            const merged = v * 2;
            newVals.push(merged);
            score += merged;
            values[next] = 0;
            i = next;
          } else {
            newVals.push(v);
          }
        }
        while (newVals.length < line.length) newVals.push(0);
        for (let i = 0; i < line.length; i++) {
          const cell = line[i];
          const key = keyOf(cell.q, cell.r);
          if ((board[key] || 0) !== newVals[i]) moved = true;
          board[key] = newVals[i] || 0;
          if (board[key] === 0) delete board[key];
        }
      }
      if (moved) {
        addRandomTile();
        updateScore();
        renderBoard();
      }
    }

    function drawBackgroundHexes() {
      const existing = Array.from(gameEl.querySelectorAll(".bghex"));
      existing.forEach(e => e.remove());
      for (const cell of cells) {
        const pos = axialToPixel(cell.q, cell.r);
        const hex = document.createElement("div");
        hex.className = "bghex";
        hex.style.position = "absolute";
        hex.style.left = pos.x + "px";
        hex.style.top = pos.y + "px";
        hex.style.width = "70px";
        hex.style.height = "70px";
        hex.style.borderRadius = "14px";
        hex.style.border = "1px solid #d0c5b6";
        hex.style.boxSizing = "border-box";
        hex.style.pointerEvents = "none";
        gameEl.appendChild(hex);
      }
    }

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (DIRECTIONS[k]) {
        e.preventDefault();
        move(k);
      }
    });

    document.querySelectorAll(".buttons button").forEach(btn => {
      btn.addEventListener("click", () => {
        const dir = btn.getAttribute("data-dir");
        move(dir);
      });
    });

    startGame();
  </script>
</body>
</html>